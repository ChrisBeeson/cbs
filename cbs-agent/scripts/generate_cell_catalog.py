#!/usr/bin/env python3
"""
Generate a global catalog of shareable CBS cells by scanning applications/*.

A cell is considered shareable when its .cbs-spec/spec.md contains:
  **shareable**: true

Outputs:
  - framework/docs/cell_catalog.md  (human-readable table)
  - framework/docs/cell_catalog.json (machine-readable list)

This does not move cells; it only indexes marked cells in-place.
"""
import json, os, re, sys

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))


def _strip_md_value(s: str) -> str:
    s = s.strip()
    if s.startswith("`") and s.endswith("`") and len(s) >= 2:
        s = s[1:-1]
    return s.strip()


def parse_spec(md_path: str) -> dict:
    """Parse .cbs-spec/spec.md into a minimal dict. Ignores unknown keys.

    Recognized keys: id, name, version, language, category, purpose,
    envelope, shareable, subscribe, publish.
    """
    data = {
        "interface": {
            "subjects": {"subscribe": [], "publish": []}
        },
        "shareable": False,
    }
    bold_kv = re.compile(r"^\s*-?\s*\*\*(.+?)\*\*:\s*(.+?)\s*$", re.IGNORECASE)
    subscribe_re = re.compile(r"^\s*-\s*(?:\*\*)?subscribe(?:\*\*)?\s*:\s*`?(.+?)`?\s*$", re.IGNORECASE)
    publish_re = re.compile(r"^\s*-\s*(?:\*\*)?publish(?:\*\*)?\s*:\s*`?(.+?)`?\s*$", re.IGNORECASE)
    envelope_re = re.compile(r"^\s*-\s*(?:\*\*)?envelope(?:\*\*)?\s*:\s*(.+?)\s*$", re.IGNORECASE)

    with open(md_path, "r", encoding="utf-8") as f:
        for raw in f:
            line = raw.rstrip("\n")
            m = bold_kv.match(line)
            if m:
                key = m.group(1).strip().lower()
                val = _strip_md_value(m.group(2))
                if key in ("id", "name", "version", "language", "category", "purpose"):
                    data[key] = val
                elif key == "shareable":
                    data["shareable"] = val.lower() in ("true", "yes", "1")
                continue

            m = subscribe_re.match(line)
            if m:
                data["interface"]["subjects"]["subscribe"].append(_strip_md_value(m.group(1)))
                continue

            m = publish_re.match(line)
            if m:
                data["interface"]["subjects"]["publish"].append(_strip_md_value(m.group(1)))
                continue

            m = envelope_re.match(line)
            if m:
                data["interface"]["envelope"] = _strip_md_value(m.group(1))
                continue

    return data


def discover_cells() -> list:
    """Return list of tuples: (app_name, cell_name, spec_path)."""
    results = []
    for base in (
        os.path.join(ROOT, "applications"),
        os.path.join(ROOT, "examples", "applications"),
    ):
        if not os.path.isdir(base):
            continue
        for app in sorted(os.listdir(base)):
            app_dir = os.path.join(base, app)
            cells_dir = os.path.join(app_dir, "cells")
            if not os.path.isdir(cells_dir):
                continue
            for cell in sorted(os.listdir(cells_dir)):
                spec = os.path.join(cells_dir, cell, "ai", "spec.md")
                if os.path.isfile(spec):
                    results.append((app, cell, spec))
    return results


def build_catalog():
    items = []
    for app, cell, spec_path in discover_cells():
        d = parse_spec(spec_path)
        if not d.get("shareable"):
            continue
        rel_spec = os.path.relpath(spec_path, ROOT)
        cell_dir = os.path.dirname(os.path.dirname(spec_path))  # .../cells/<cell>
        rel_cell_dir = os.path.relpath(cell_dir, ROOT)
        items.append(
            {
                "id": d.get("id", cell),
                "name": d.get("name", cell),
                "version": d.get("version", ""),
                "language": d.get("language", ""),
                "category": d.get("category", ""),
                "envelope": d.get("interface", {}).get("envelope", ""),
                "subjects": d.get("interface", {}).get("subjects", {"subscribe": [], "publish": []}),
                "app": app,
                "cell": cell,
                "path": rel_cell_dir,
                "spec": rel_spec,
            }
        )
    return items


def write_outputs(items: list) -> None:
    docs_dir = os.path.join(ROOT, "framework", "docs")
    os.makedirs(docs_dir, exist_ok=True)

    # JSON
    json_path = os.path.join(docs_dir, "cell_catalog.json")
    with open(json_path, "w", encoding="utf-8") as f:
        json.dump({"cells": items}, f, indent=2, ensure_ascii=False)

    # Markdown
    md_path = os.path.join(docs_dir, "cell_catalog.md")
    with open(md_path, "w", encoding="utf-8") as out:
        out.write("## CBS Shareable Cell Catalog\n\n")
        out.write("- Generated by cbs-agent/scripts/generate_cell_catalog.py\n\n")
        out.write("| App | Cell | Id | Version | Category | Lang | Subscribes | Publishes | Path |\n")
        out.write("| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n")
        for it in items:
            sub = ", ".join(it.get("subjects", {}).get("subscribe", []))
            pub = ", ".join(it.get("subjects", {}).get("publish", []))
            out.write(
                f"| {it['app']} | {it['cell']} | {it['id']} | {it['version']} | {it['category']} | {it['language']} | {sub} | {pub} | {it['path']} |\n"
            )


def main() -> int:
    items = build_catalog()
    write_outputs(items)
    print(f"Catalog entries: {len(items)}")
    return 0


if __name__ == "__main__":
    sys.exit(main())


